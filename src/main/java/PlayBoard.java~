import java.util.List;
import java.util.LinkedList;

public class PlayBoard{
    public int width;
    public int height;
    public class Vertex{
        public int x;
        public int y;
	public int distance;
        public List<Edge> edges = new LinkedList<Edge>();
	public Vertex prev;
        public Vertex(int x, int y){
            this.x = x;
            this.y = y;
        }
	public void link(int xDelta, int yDelta){
	    boolean diagonal = xDelta != 0 && yDelta != 0;
	    edges.add(new Edge(vertices[(y + yDelta) * width + x + xDelta],diagonal? 14 : 10));
	}
	@Override
	    public String toString(){
	    return String.format("%s,%s",x,y);
	} 
    }
    public class Edge{
        public Vertex terminus;
        public int distance;
        public Edge(Vertex terminus, int distance){
            this.terminus = terminus;
            this.distance = distance;
        }
    }
    public Vertex[] vertices;
    public PlayBoard(int width, int height){
        this.width = width;
        this.height = height;
        vertices = new Vertex[width * height];
        for(int row = 0; row < height; row++){
            for(int col = 0; col < width; col++){
                vertices[row * width + col] = new Vertex(row,col);
            }
        }
        for(Vertex v : vertices){
            boolean left = v.x == 0;
            boolean right = v.x == width - 1;
            boolean top = v.y == 0;
            boolean bottom = v.y == height -1;
            if(!left){
                v.link(-1,0);
                if(!top){
                    v.link(-1,-1);
                }
                if(!bottom){
                    v.link(-1,1);
                }
            }
	    if(!top){
		v.link(0,-1);
	    }
	    if(!bottom){
		v.link(0,1);
	    }
            if(!right){
                v.link(1,0);
                if(!top){
                    v.link(1,-1);
                }
                if(!bottom){
                    v.link(1,1);
                }
            }
        }
    }
    public List<Vertex> solve(int sx, int sy, int dx, int dy){
	HeapBasedPriorityQueue<Vertex> unsolved = new HeapBasedPriorityQueue<Vertex>();
	Vertex current = vertices[sy * width + sx];
	Vertex end = vertices[dy * width + dx];
	for(Vertex v : vertices){
	    if(v == current){
		continue;
	    }
	    v.distance = Integer.MAX_VALUE;
	    unsolved.add(v.distance,v);
	}
	current.distance = 0;
	while(unsolved.size() > 0){
	    for(Edge e : current.edges){
		Vertex neighbour = e.terminus;
		int tendril = current.distance + e.distance;
		if(tendril < neighbour.distance){
		    neighbour.distance = tendril;
		    neighbour.prev = current;
		    unsolved.reprioritize(neighbour,priority);
		}
	    ]}
	    if(current == end){
		break;
	    }
	    current = unsolved.popDominant();
	    List<Vertex> result = new LinkedList<Vertex>();
	    for(Vertex step = end; step != null; step = step.prev){
		result.add(step);
	    }
	    return result;
	}
    }
}
